{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"ee \u2014 Lightweight C Utility Library","text":"<p>ee is a header-only C library that provides common data structures and utilities. It is designed to be self-contained and easily integrated into any C99 project, as it has no external dependencies.</p>"},{"location":"#features","title":"Features","text":"<p>The <code>eelib</code> library provides the following modules:</p> <ul> <li> <p>Memory management</p> <ul> <li><code>ee_arena.h</code>: A fast, linear arena allocator.</li> <li><code>ee_core.h</code>: Support for optional custom allocators.</li> </ul> </li> <li> <p>Dynamic containers</p> <ul> <li><code>ee_array.h</code>: Dynamic arrays (also known as resizable vectors).</li> <li><code>ee_dict.h</code>: Hash maps with open addressing.</li> <li><code>ee_heap.h</code>: Binary heaps, often used for priority queues.</li> <li><code>ee_set.h</code>: Hash sets for efficient item lookup.</li> <li><code>ee_grid.h</code>: 2D grids, useful for spatial data or games.</li> </ul> </li> <li> <p>String utilities</p> <ul> <li><code>ee_string.h</code>: Utilities for dynamic strings, fixed-length buffers, and lightweight string views.</li> </ul> </li> <li> <p>System utilities</p> <ul> <li><code>ee_fs.h</code>: Filesystem traversal and file utilities (Windows-only).</li> <li><code>ee_random.h</code>: Random number generation (uniform and normal distributions).</li> </ul> </li> </ul>"},{"location":"#platforms-and-compilers","title":"Platforms and Compilers","text":"<ul> <li>Minimum C Standard: C99</li> <li>Tested Compilers: MSVC, GCC</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>As ee is a header-only library, you do not need to build it separately. You can use it in your project in two ways.</p>"},{"location":"#option-1-clone-the-repository","title":"Option 1: Clone the repository","text":"<p>Note</p> <p>This method gives you access to all modules.</p> <ol> <li> <p>Clone the repository:</p> <pre><code>git clone https://github.com/eesuck1/eelib.git\n</code></pre> </li> <li> <p>Add the <code>utils/</code> directory to your project's include path.</p> </li> <li> <p>Include the headers you need in your C source files:</p> <pre><code>#include \"ee_array.h\"\n#include \"ee_dict.h\"\n#include \"ee_string.h.h\"\n// ...and so on\n</code></pre> </li> </ol>"},{"location":"#option-2-copy-headers-individually","title":"Option 2: Copy headers individually","text":"<p>You can also copy individual header files directly into your project.</p> <p>Important</p> <p>Some headers depend on others. Make sure you copy all required files.</p> Header Description Dependencies <code>ee_arena.h</code> Provides a linear memory allocator (arena). Depends on <code>ee_core.h</code>. <code>ee_array.h</code> Provides a dynamic, resizable array (vector). Depends on <code>ee_core.h</code>. <code>ee_core.h</code> Defines core types, macros, SIMD abstractions, and base allocators. Independent. <code>ee_dict.h</code> Provides an open-addressing hash map. Depends on <code>ee_core.h</code>. <code>ee_random.h</code> Provides PRNG for uniform and normal distributions. Depends on <code>ee_core.h</code>. <code>ee_string.h</code> Provides dynamic strings, fixed-buffers, and string views. Depends on <code>ee_core.h</code>."},{"location":"#configuration","title":"Configuration","text":"<p>You can configure the library's behavior by defining specific macros before including its headers.</p>"},{"location":"#disabling-assertions-ee_no_assert","title":"Disabling assertions (<code>EE_NO_ASSERT</code>)","text":"<p>By default, the library uses <code>EE_ASSERT()</code> to validate conditions at runtime (e.g., checking for null pointers). You can disable these checks for performance in a release build.</p> <p>Define <code>EE_NO_ASSERT</code> before including any <code>ee</code> headers to remove all assertion checks at compile time.</p> Mode Description With <code>EE_ASSERT</code>  (default) <code>EE_ASSERT</code> validates conditions and terminates on failure. With <code>EE_NO_ASSERT</code> Assertions are removed \u2014 no checks or runtime overhead. <p>Usage example:</p> <pre><code>// Disable all assertions for this build\n#define EE_NO_ASSERT\n\n#include \"ee_core.h\"\n#include \"ee_array.h\"\n</code></pre>"},{"location":"#simd-support","title":"SIMD support","text":"<p>The library includes support for SIMD (Single Instruction, Multiple Data) optimizations. The available levels are:</p> Macro Value Description <code>EE_SIMD_LEVEL_NONE</code> 0 No SIMD instructions; all operations are scalar. <code>EE_SIMD_LEVEL_SSE</code> 1 Supports 128-bit vector instructions for ints and floats. <code>EE_SIMD_LEVEL_AVX</code>(default) 2 Supports 256-bit vector instructions for higher parallelism."},{"location":"#roadmap","title":"Roadmap","text":"<p>Work is currently in progress for:</p> <ul> <li>Dynamic Heap (<code>ee_heap</code>)</li> <li>File System Utilities (<code>ee_fs</code>)</li> <li>Double-Ended Queue (<code>ee_deq</code>)</li> <li>...and more.</li> </ul> <p>These modules will be added to the documentation as they become stable.</p>"},{"location":"glossary/","title":"Glossary","text":"<p>This page defines key terms and concepts used throughout the <code>eelib</code> library. </p> <p>To find a specific term, use: </p> <ul> <li>the search box on the top panel</li> <li>the category buttons below to filter the list</li> </ul> Core Concepts Data Structures Memory Management Algorithms Platform &amp; SIMD"},{"location":"glossary/#core-concepts","title":"Core Concepts","text":"<p>Core ideas and types that are used by all other modules.</p>"},{"location":"glossary/#allocator-interface","title":"Allocator (Interface)","text":"<p> The standard <code>eelib</code> interface (defined in <code>ee_core.h</code>) that provides a generic API for memory operations (<code>alloc_fn</code>, <code>realloc_fn</code>, <code>free_fn</code>).</p>"},{"location":"glossary/#bincmp","title":"BinCmp","text":"<p> A function pointer type (<code>int (*)(const void* a, const void* b)</code>) used for generic comparison operations, such as sorting. It must return a negative, zero, or positive value based on the comparison.</p>"},{"location":"glossary/#type-punning","title":"Type-punning","text":"<p> An operation (e.g., <code>*(u64*)ptr</code>) that reinterprets a block of memory as a different type. <code>eelib</code> provides safe (<code>ee_eq_safe_...</code>) and fast (<code>ee_eq_...</code>) versions of these operations.</p>"},{"location":"glossary/#data-structures","title":"Data Structures","text":"<p>The main data structure modules provided by <code>eelib</code>.</p>"},{"location":"glossary/#arena","title":"Arena","text":"<p> A Linear Allocator that allocates memory sequentially from a single, contiguous block. Allocations are fast, but individual blocks cannot be freed.</p>"},{"location":"glossary/#array-dynamic","title":"Array (Dynamic)","text":"<p> A type-generic dynamic array (vector) that manages a contiguous, resizable memory buffer. It operates on raw bytes by tracking an <code>elem_size</code>.</p>"},{"location":"glossary/#memory-management","title":"Memory Management","text":"<p>Terms related to how memory is allocated, aligned, and freed.</p>"},{"location":"glossary/#alignment","title":"Alignment","text":"<p> The requirement that a memory address must be a multiple of a certain value (e.g., 16 bytes, defined by <code>EE_MAX_ALIGN</code>).</p>"},{"location":"glossary/#base-arena","title":"<code>base</code> (Arena)","text":"<p>  A pointer (<code>u8*</code>) within the <code>Arena</code> struct that points to the raw, unaligned memory block returned by the underlying Allocator. This is the pointer that must be used to free the entire arena's memory.</p>"},{"location":"glossary/#buffer-arena","title":"<code>buffer</code> (Arena)","text":"<p>  A pointer (<code>u8*</code>) within the <code>Arena</code> struct that points to the aligned, usable start of the memory block from which allocations are made. This pointer is derived from <code>base</code> but adjusted for alignment.</p>"},{"location":"glossary/#ee_no_rewind","title":"<code>EE_NO_REWIND</code>","text":"<p>  A constant (defined as <code>0</code>) used as the <code>rewind_depth</code> parameter in <code>ee_arena_new()</code>. It signifies that the arena should not allocate a Mark stack, thus disabling the <code>ee_arena_mark()</code> and <code>ee_arena_rewind()</code> features for that instance.</p>"},{"location":"glossary/#free-arena","title":"Free (Arena)","text":"<p> In the context of an arena, this term refers to deallocating the entire memory block used by the arena. This is done by calling <code>ee_arena_free()</code>, which uses the underlying Allocator to free the <code>base</code> pointer. It does not refer to freeing individual allocations.</p>"},{"location":"glossary/#linear-allocation","title":"Linear Allocation","text":"<p> The strategy used by an Arena. Memory is allocated by simply advancing an \"offset\" pointer (or \"watermark\") in a single buffer.</p>"},{"location":"glossary/#mark-arena","title":"Mark (Arena)","text":"<p> A snapshot of an Arena's current allocation offset, stored on a stack. This allows the arena to Rewind to this \"save point\".</p>"},{"location":"glossary/#offset-arena","title":"Offset (Arena)","text":"<p>  An internal <code>size_t</code> value in the <code>Arena</code> struct that tracks the current \"top\" or \"watermark\" of allocations. It represents the total number of bytes used from the <code>buffer</code> so far.</p>"},{"location":"glossary/#reset-arena","title":"Reset (Arena)","text":"<p>  The operation of setting an arena's Offset (and <code>mark</code> count) back to zero. This effectively \"frees\" all memory within the arena, making its full capacity available for new allocations without deallocating or reallocating the underlying <code>buffer</code>.</p>"},{"location":"glossary/#rewind-arena","title":"Rewind (Arena)","text":"<p> The operation of restoring an Arena's allocation Offset to the value of the most recently saved Mark. This effectively frees all memory that was allocated after that mark was created.</p>"},{"location":"glossary/#algorithms","title":"Algorithms","text":"<p>Specific algorithms used within <code>eelib</code> modules.</p>"},{"location":"glossary/#introsort","title":"Introsort","text":"<p> A hybrid sorting algorithm used by <code>ee_array_sort()</code>. It begins as a Quicksort but switches to a Heapsort if the recursion depth exceeds a limit, guaranteeing O(n log n) performance.</p>"},{"location":"glossary/#swap-and-pop","title":"Swap and Pop","text":"<p> An O(1) (constant time) algorithm for removing an element from an <code>Array</code> by overwriting it with the last element and then shrinking the array size by one. This operation does not preserve the array's order.</p>"},{"location":"glossary/#platform-simd","title":"Platform &amp; SIMD","text":"<p>Terms related to platform-specific, low-level, or compiler-dependent features.</p>"},{"location":"glossary/#simd","title":"SIMD","text":"<p> (Single Instruction, Multiple Data). A class of CPU instructions (like SSE or AVX) that perform the same operation on multiple data points simultaneously. <code>ee_core.h</code> provides an abstraction layer over these.</p>"},{"location":"glossary/#sse-avx","title":"SSE / AVX","text":"<p> (Streaming SIMD Extensions / Advanced Vector Extensions). Specific SIMD instruction sets supported by modern x86 CPUs.</p>"},{"location":"headers/Arena/arena/","title":"ee_arena.h","text":"<p><code>ee_arena.h</code> provides a linear memory allocator with optional rewind support.</p> <p>It defines the primary <code>Arena</code> structure, which manages memory allocation from a contiguous buffer. This module is ideal for temporary allocations where memory can be freed all at once or reverted to a previous state efficiently.</p> <p>The arena can be wrapped as a standard <code>Allocator</code> interface using <code>ee_arena_allocator()</code> for compatibility with other <code>eelib</code> components that require an allocator.</p>"},{"location":"headers/Arena/arena/#defines","title":"Defines","text":"Macro Description <code>EE_NO_REWIND</code> A constant value (typically <code>0</code>) used as the <code>rewind_depth</code> parameter in <code>ee_arena_new()</code> to specify that the arena should not allocate a rewind stack. This disables the <code>ee_arena_mark()</code> and <code>ee_arena_rewind()</code> functions for that instance."},{"location":"headers/Arena/arena/#structures","title":"Structures","text":"<p>Structure <code>struct Arena</code> representing the memory arena. It manages the underlying buffer, tracks the current allocation offset, and maintains the optional rewind stack.</p> <pre><code>typedef struct Arena\n{\n    size_t* marks;       \n    u8* buffer;         \n    u8* base;          \n\n    size_t  size;       \n    size_t  offset;    \n    size_t  mark;        \n    size_t  marks_depth;\n\n    Allocator allocator;\n} Arena;\n</code></pre> Structure members Members Type Description <code>marks</code> <code>size_t*</code> Pointer to the rewind stack, which stores <code>offset</code> values. <code>NULL</code> if <code>marks_depth</code> is <code>EE_NO_REWIND</code>. <code>buffer</code> <code>u8*</code> Pointer to the aligned start of the usable memory buffer where allocations occur. <code>base</code> <code>u8*</code> Pointer to the raw, unaligned memory block received from the underlying <code>allocator</code>. This is the pointer used for <code>ee_arena_free()</code>. <code>size</code> <code>size_t</code> Total usable capacity of the <code>buffer</code> in bytes. <code>offset</code> <code>size_t</code> The current allocation \"watermark\". All memory from <code>buffer</code> to <code>buffer + offset</code> is considered used. <code>mark</code> <code>size_t</code> The current count of active rewind marks on the <code>marks</code> stack. <code>marks_depth</code> <code>size_t</code> The maximum number of marks that can be stored. <code>allocator</code> <code>Allocator</code> The underlying allocator interface (e.g., default malloc/free) used to acquire the <code>base</code> memory block."},{"location":"headers/Arena/arena/#functions","title":"Functions","text":"EE_INLINE Arena ee_arena_new(size_t size, size_t rewind_depth, Allocator* allocator) <p>Syntax</p> <pre><code>Arena ee_arena_new(size_t size, size_t rewind_depth, Allocator* allocator);\n</code></pre> <p>Description</p> <p>Initializes and allocates the memory for a new <code>Arena</code> object.</p> <p>This function reserves a contiguous block of memory from the specified <code>allocator</code> (or the default if <code>NULL</code>). It also reserves space for the rewind stack if <code>rewind_depth</code> is not <code>EE_NO_REWIND</code>.</p> <p>Parameters</p> Name Type Description <code>size</code> <code>size_t</code> Total capacity of the arena buffer in bytes. <code>rewind_depth</code> <code>size_t</code> Number of marks that can be stored for rewinding. Use <code>EE_NO_REWIND</code> to disable this feature. <code>allocator</code> <code>Allocator*</code> Optional custom allocator. Note: Pass <code>NULL</code> to use the default allocator. <p>Returns</p> <p>An initialized <code>Arena</code> structure. On allocation failure, this function will assert (if <code>EE_ASSERT</code> is enabled).</p> <p>Example</p> <pre><code>// Create a 1MB arena with 16 rewind levels\nArena arena = ee_arena_new(1024 * 1024, 16, NULL);\n\n// ... use the arena ...\n\n// Always free the arena when done\nee_arena_free(&amp;arena);\n</code></pre> EE_INLINE void ee_arena_clear(Arena* arena) <p></p> <p>Syntax</p> <pre><code>void ee_arena_clear(Arena* arena);\n</code></pre> <p>Description</p> <p>Clears the entire arena buffer by setting its contents to zero using <code>memset</code>.</p> <p>Important</p> <p>This function does not reset the <code>offset</code> or <code>mark</code> counters. To \"free\" all memory and restart allocation, use <code>ee_arena_reset()</code>.</p> <p>Parameters</p> Name Type Description <code>arena</code> <code>Arena*</code> A pointer to the arena object to clear. <p>See Also</p> <ul> <li><code>ee_arena_reset()</code></li> </ul> EE_INLINE void* ee_arena_alloc(Arena* arena, size_t size) <p></p> <p>Syntax</p> <pre><code>void* ee_arena_alloc(Arena* arena, size_t size);\n</code></pre> <p>Description</p> <p>Allocates a block of memory from the arena with default alignment (defined by <code>EE_MAX_ALIGN</code>). This is the primary, general-purpose allocation function.</p> <p>Allocations are linear and advance the arena's internal offset.</p> <p>Parameters</p> Name Type Description <code>arena</code> <code>Arena*</code> A pointer to the arena object. <code>size</code> <code>size_t</code> The number of bytes to allocate. <p>Returns</p> <p>A pointer to the allocated block, or <code>NULL</code> if the arena does not have enough remaining space.</p> <p>Example</p> <pre><code>MyStruct* s = ee_arena_alloc(&amp;arena, sizeof(*s));\n\nif (s != NULL)\n{\n// ... initialize and use s ...\n}\n</code></pre> <p>See Also</p> <ul> <li><code>ee_arena_alloc_al()</code></li> </ul> EE_INLINE void* ee_arena_alloc_al(Arena* arena, size_t size, size_t align) <p></p> <p>Syntax</p> <pre><code>void* ee_arena_alloc_al(Arena* arena, size_t size, size_t align);\n</code></pre> <p>Description</p> <p>Allocates a block of memory from the arena with a custom alignment.</p> <p>The <code>align</code> parameter must be a power of two. If <code>align</code> is 1, no alignment padding is added beyond the natural offset.</p> <p>Parameters</p> Name Type Description <code>arena</code> <code>Arena*</code> A pointer to the arena object. <code>size</code> <code>size_t</code> The number of bytes to allocate. <code>align</code> <code>size_t</code> The required alignment for the returned pointer (must be a power of two). <p>Returns</p> <p>A pointer to the allocated block with the specified alignment, or <code>NULL</code> if the arena does not have enough remaining space.</p> <p>Example</p> <pre><code>// Allocate 64 bytes aligned to a 16-byte boundary\nvoid* aligned_mem = ee_arena_alloc_al(&amp;arena, 64, 16);\n</code></pre> EE_INLINE void ee_arena_mark(Arena* arena) <p></p> <p>Syntax</p> <pre><code>void ee_arena_mark(Arena* arena);\n</code></pre> <p>Description</p> <p>Saves the current allocation offset (<code>arena-&gt;offset</code>) onto the rewind stack. This creates a \"save point\" that can be returned to using <code>ee_arena_rewind()</code>.</p> <p>This function will assert if the arena was created with <code>EE_NO_REWIND</code> or if the mark stack is full.</p> <p>Parameters</p> Name Type Description <code>arena</code> <code>Arena*</code> A pointer to the arena object. <p>See Also</p> <ul> <li><code>ee_arena_rewind()</code></li> </ul> EE_INLINE void ee_arena_rewind(Arena* arena) <p></p> <p>Syntax</p> <pre><code>void ee_arena_rewind(Arena* arena);\n</code></pre> <p>Description</p> <p>Restores the arena's allocation offset to the last saved mark from the rewind stack. This effectively \"frees\" all memory allocated since that mark was saved.</p> <p>This function will assert if the mark stack is empty (a \"stack underflow\").</p> <p>Parameters</p> Name Type Description <code>arena</code> <code>Arena*</code> A pointer to the arena object. <p>Example</p> <pre><code>// Save state\nee_arena_mark(&amp;arena);\n\n// Perform temporary allocations\nvoid* temp_obj_1 = ee_arena_alloc(&amp;arena, 32);\nvoid* temp_obj_2 = ee_arena_alloc(&amp;arena, 64);\n\n// ... use temp objects ...\n\n// Free all memory back to the mark\nee_arena_rewind(&amp;arena); \n</code></pre> EE_INLINE void ee_arena_reset(Arena* arena) <p></p> <p>Syntax</p> <pre><code>void ee_arena_reset(Arena* arena);\n</code></pre> <p>Description</p> <p>Resets the arena to its initial state by setting the allocation offset and mark count to zero. This is the fastest way to free all memory in the arena for reuse.</p> <p>This function does not zero the memory content.</p> <p>Parameters</p> Name Type Description <code>arena</code> <code>Arena*</code> A pointer to the arena object. <p>See Also</p> <ul> <li><code>ee_arena_clear()</code></li> </ul> EE_INLINE void ee_arena_free(Arena* arena) <p></p> <p>Syntax</p> <pre><code>void ee_arena_free(Arena* arena);\n</code></pre> <p>Description</p> <p>Frees the entire memory block used by the arena, including the buffer and mark stack. This calls the <code>free_fn</code> of the underlying allocator on the <code>base</code> pointer.</p> <p>After this call, the <code>Arena</code> struct is zeroed and must not be used again unless re-initialized with <code>ee_arena_new()</code>.</p> <p>Parameters</p> Name Type Description <code>arena</code> <code>Arena*</code> A pointer to the arena object to be destroyed. <p>See Also</p> <ul> <li><code>ee_arena_new()</code></li> </ul> EE_INLINE Allocator ee_arena_allocator(Arena* arena) <p></p> <p>Syntax</p> <pre><code>Allocator ee_arena_allocator(Arena* arena);\n</code></pre> <p>Description</p> <p>Wraps an existing <code>Arena</code> instance in a standard <code>Allocator</code> interface.</p> <p>This allows the arena to be passed to other functions or systems that require a generic <code>Allocator</code> object (e.g., data structures like lists or hash maps). The <code>arena</code> pointer is stored in the <code>Allocator.context</code> field.</p> <p>Interface Behavior</p> <p>The returned allocator has specific behaviors tied to the arena's linear nature:</p> <ul> <li><code>alloc_fn</code>: Calls <code>eev_arena_alloc_fn()</code>, which allocates memory from the arena.</li> <li><code>realloc_fn</code>: Calls <code>eev_arena_realloc_fn()</code>, which always returns <code>NULL</code>. Arenas do not support reallocation.</li> <li><code>free_fn</code>: Calls <code>eev_arena_free_fn()</code>, which does nothing. Arenas do not support freeing individual blocks.</li> </ul> <p>Parameters</p> Name Type Description <code>arena</code> <code>Arena*</code> A pointer to the initialized arena object to be wrapped. <p>Returns</p> <p>An <code>Allocator</code> struct configured to use the provided <code>arena</code> for allocations.</p> <p>See Also</p> <ul> <li><code>ee_arena_new()</code></li> <li><code>ee_arena_alloc()</code></li> <li><code>eev_arena_alloc_fn()</code></li> <li><code>eev_arena_realloc_fn()</code></li> <li><code>eev_arena_free_fn()</code></li> <li><code>struct Allocator</code></li> </ul>"},{"location":"headers/Arena/arena/#allocator-functions","title":"Allocator Functions","text":"<p>These functions are the internal implementations used by the <code>struct Allocator</code> returned by <code>ee_arena_allocator()</code>. End-users typically do not call these functions directly.</p> EE_INLINE void* eev_arena_alloc_fn(Allocator* allocator, size_t size) <p></p> <p>Syntax</p> <pre><code>void* eev_arena_alloc_fn(Allocator* allocator, size_t size);\n</code></pre> <p>Description</p> <p>The <code>alloc_fn</code> implementation for the arena-backed allocator.</p> <p>It retrieves the <code>Arena</code> pointer from <code>allocator-&gt;context</code> and calls <code>ee_arena_alloc()</code> to perform a linear allocation.</p> <p>Parameters</p> Name Type Description <code>allocator</code> <code>Allocator*</code> The allocator interface, which must have its <code>context</code> set to a valid <code>Arena*</code>. <code>size</code> <code>size_t</code> The number of bytes to allocate. <p>Returns</p> <p>A pointer to the allocated memory, or <code>NULL</code> if the arena is full.</p> <p>See Also</p> <ul> <li><code>ee_arena_allocator()</code></li> <li><code>ee_arena_alloc()</code></li> </ul> EE_INLINE void* eev_arena_realloc_fn(Allocator* allocator, void* buffer, size_t old_size, size_t new_size) <p></p> <p>Syntax</p> <pre><code>void* eev_arena_realloc_fn(Allocator* allocator, void* buffer, size_t old_size, size_t new_size);\n</code></pre> <p>Description</p> <p>The <code>realloc_fn</code> implementation for the arena-backed allocator.</p> <p>This function always returns <code>NULL</code>. Due to their linear nature, arenas do not support reallocating individual memory blocks.</p> <p>Parameters</p> <p>Note: As this operation is not supported by the arena, all parameters are ignored.</p> Name Type Description <code>allocator</code> <code>Allocator*</code> \u2014 <code>buffer</code> <code>void*</code> \u2014 <code>old_size</code> <code>size_t</code> \u2014 <code>new_size</code> <code>size_t</code> \u2014 <p>Returns</p> <p>Always <code>NULL</code>.</p> <p>See Also</p> <ul> <li><code>ee_arena_allocator()</code></li> </ul> EE_INLINE void eev_arena_free_fn(Allocator* allocator, void* buffer) <p></p> <p>Syntax</p> <pre><code>void eev_arena_free_fn(Allocator* allocator, void* buffer);\n</code></pre> <p>Description</p> <p>The <code>free_fn</code> implementation for the arena-backed allocator.</p> <p>This function does nothing (it is a \"no-op\"). Arenas do not support freeing individual memory blocks. All memory must be freed at once by resetting or freeing the entire arena.</p> <p>Parameters</p> <p>Note: As this operation is not supported by the arena, all parameters are ignored.</p> Name Type Description <code>allocator</code> <code>Allocator*</code> \u2014 <code>buffer</code> <code>void*</code> \u2014 <p>See Also</p> <ul> <li><code>ee_arena_allocator()</code></li> <li><code>ee_arena_reset()</code></li> <li><code>ee_arena_free()</code></li> </ul>"},{"location":"headers/Array/array/","title":"ee_array.h","text":"<p><code>ee_array.h</code> provides a type-generic dynamic array (vector) implementation.</p> <p>It defines the <code>Array</code> structure, which manages a contiguous, resizable memory buffer. This module is designed to be type-agnostic; it operates on raw bytes by tracking the <code>elem_size</code> (element size). All element manipulation (push, pop, set, at) is done via <code>memcpy</code> or direct byte-pointer access.</p>"},{"location":"headers/Array/array/#defines","title":"Defines","text":"<p>This header provides several helper macros for constants and type-safe element access.</p>"},{"location":"headers/Array/array/#constants","title":"Constants","text":"Macro Description <code>EE_ARRAY_INVALID</code> A sentinel value (<code>(size_t)-1</code>) returned by search functions (e.g., <code>ee_array_find()</code>) when no matching element is found. <code>EE_ARRAY_SORT_TH</code> The size threshold (typically <code>16</code> elements) for <code>ee_array_introsort()</code>. Sub-arrays smaller than or equal to this size will be sorted using the faster Insertion Sort algorithm."},{"location":"headers/Array/array/#helper-macros","title":"Helper Macros","text":"Macro Description <code>EE_ARRAY_RECAST(v_ptr, i, dtype)</code> (Recommended) Gets a correctly typed pointer (<code>dtype*</code>) to the element at index <code>i</code> from an array pointer <code>v_ptr</code>. This is the safest way to access elements.  Example: <code>int* val = EE_ARRAY_RECAST(&amp;my_array, 0, int);</code> <code>EE_ARRAY_PTR_GET(v_ptr, i, d_ptr)</code> Copies the element at index <code>i</code> from an array pointer <code>v_ptr</code> into the destination pointer <code>d_ptr</code>.  Example: <code>int val; EE_ARRAY_PTR_GET(&amp;my_array, 0, &amp;val);</code> <code>EE_ARRAY_GET(v, i, d)</code> Copies the element at index <code>i</code> from an array struct <code>v</code> into the destination variable <code>d</code>.  Example: <code>int val; EE_ARRAY_GET(my_array, 0, val);</code>"},{"location":"headers/Array/array/#structures","title":"Structures","text":"<p>Structure <code>struct Array</code> defines the core container for a resizable, contiguous array. All array operations depend on these fields to manage allocation and indexing.</p> <pre><code>typedef struct Array\n{\n    size_t top; \n    size_t cap; \n    size_t elem_size; \n    u8* buffer; \n    Allocator allocator; \n} Array;\n</code></pre> Structure members <p>Important</p> <p>Note that <code>top</code> and <code>cap</code> store the size in bytes, not element count. Use <code>ee_array_len()</code> to get the number of elements.</p> Members Type Description <code>top</code> <code>size_t</code> The current size (length) of the array in bytes. (<code>top == ee_array_len() * elem_size</code>). <code>cap</code> <code>size_t</code> The total allocated capacity of the <code>buffer</code> in bytes. <code>elem_size</code> <code>size_t</code> The size of a single element in bytes (e.g., <code>sizeof(int)</code>). <code>buffer</code> <code>u8*</code> Pointer to the contiguous memory block holding the elements. <code>allocator</code> <code>Allocator</code> The underlying allocator used for <code>buffer</code> (e.g., default malloc/free)."},{"location":"headers/Array/array/#enumerations-enum","title":"Enumerations (enum)","text":"<p><code>enum ArraySortType</code> lists available sorting algorithms for internal operations.</p> <pre><code>typedef enum ArraySortType\n{\n    EE_SORT_DEFAULT = 0,\n    EE_SORT_INSERT  = 1,\n    EE_SORT_QUICK   = 2,\n    EE_SORT_HEAP    = 3,\n    EE_SORT_INTRO   = 4,\n} ArraySortType;\n</code></pre> Enum values Value Description <code>EE_SORT_DEFAULT</code> Defaults to Introspective Sort (<code>EE_SORT_INTRO</code>). <code>EE_SORT_INSERT</code> Insertion Sort. Efficient for small or nearly-sorted arrays. <code>EE_SORT_QUICK</code> Quicksort. Fast on average, but with O(n<sup>2</sup>) worst-case. <code>EE_SORT_HEAP</code> Heapsort. Guaranteed O(n log n) performance. <code>EE_SORT_INTRO</code> Introspective Sort. A hybrid that starts with Quicksort and switches to Heapsort to prevent worst-case O(n<sup>2</sup>) behavior."},{"location":"headers/Array/array/#functions-lifecycle","title":"Functions (Lifecycle)","text":"EE_INLINE Array ee_array_new(size_t size, size_t elem_size, const Allocator* allocator) <p>Syntax</p> <pre><code>Array ee_array_new(size_t size, size_t elem_size, const Allocator* allocator);\n</code></pre> <p>Description</p> <p>Initializes and allocates memory for a new <code>Array</code> object.</p> <p>This function allocates an initial buffer large enough to hold <code>size</code> elements. The <code>Array.top</code> is initialized to <code>0</code>, and <code>Array.cap</code> is set to <code>size * elem_size</code>.</p> <p>Parameters</p> Name Type Description <code>size</code> <code>size_t</code> The initial element capacity (number of elements, not bytes). Must be greater than 0. <code>elem_size</code> <code>size_t</code> The size of a single element. Use <code>sizeof(your_type)</code>. Must be greater than 0. <code>allocator</code> <code>const Allocator*</code> Optional. A pointer to a custom <code>Allocator</code>. Pass <code>NULL</code> to use the default <code>eelib</code> allocator. <p>Returns</p> <p>An initialized <code>Array</code> structure.</p> <p>Example</p> <pre><code>// Create an array to hold 16 integers\nArray int_array = ee_array_new(16, sizeof(int), NULL);\n\n// ... use the array ...\n\nee_array_free(&amp;int_array);\n</code></pre> <p>See Also</p> <ul> <li><code>ee_array_free()</code></li> </ul> EE_INLINE Array ee_array_copy(Array* array, Allocator* allocator) <p></p> <p>Syntax</p> <pre><code>Array ee_array_copy(Array* array, Allocator* allocator);\n</code></pre> <p>Description</p> <p>Creates a deep copy of an existing array.</p> <p>A new <code>Array</code> struct is created, and a new memory buffer is allocated for it using the specified <code>allocator</code> (or the default if <code>NULL</code>).</p> <p>Note</p> <p>This function copies the entire capacity (<code>cap</code>) of the source array's buffer, not just the currently used portion (<code>top</code>). The <code>top</code> value of the new array is set to match the source array's <code>top</code>.</p> <p>Parameters</p> Name Type Description <code>array</code> <code>Array*</code> Pointer to the source <code>Array</code> to be copied. <code>allocator</code> <code>Allocator*</code> Optional. The allocator to be used for the new array's buffer. Pass <code>NULL</code> to use the default allocator. <p>Returns</p> <p>A new <code>Array</code> struct containing a deep copy of the source array's data.</p> <p>Example</p> <pre><code>// Create an original array\nArray arr_a = ee_array_new(4, sizeof(int), NULL);\nint x = 5;\nee_array_push(&amp;arr_a, (u8*)&amp;x); // arr_a has [5]\n\n// Create a copy\nArray arr_b = ee_array_copy(&amp;arr_a, NULL);\n\n// Now, arr_a and arr_b are independent.\n// Let's modify arr_b.\nint y = 10;\nee_array_push(&amp;arr_b, (u8*)&amp;y); // arr_b has [5, 10]\n\n// arr_a is unchanged (still has [5])\n\n// They have different memory buffers\n// EE_ASSERT(arr_a.buffer != arr_b.buffer);\n\n// Clean up both arrays\nee_array_free(&amp;arr_a);\nee_array_free(&amp;arr_b);\n</code></pre> <p>See Also</p> <ul> <li><code>ee_array_new()</code></li> <li><code>ee_array_free()</code></li> </ul> EE_INLINE void ee_array_free(Array* array) <p></p> <p>Syntax</p> <pre><code>void ee_array_free(Array* array);\n</code></pre> <p>Description</p> <p>Frees the internal buffer of the array using its allocator and zeroes the <code>Array</code> struct. After this call, the array is no longer valid and must not be used.</p> <p>Parameters</p> Name Type Description <code>array</code> <code>Array*</code> Pointer to the <code>Array</code> to be freed and destroyed. <p>See Also</p> <ul> <li><code>ee_array_new()</code></li> </ul>"},{"location":"headers/Array/array/#functions-capacity-size","title":"Functions (Capacity &amp; Size)","text":"EE_INLINE int ee_array_full(const Array* array) <p>Syntax</p> <pre><code>int ee_array_full(const Array* array);\n</code></pre> <p>Description</p> <p>Checks if the array's used size in bytes (<code>top</code>) has reached its total capacity (<code>cap</code>).</p> <p>Parameters</p> Name Type Description <code>array</code> <code>const Array*</code> Pointer to the <code>Array</code> to check for fullness. <p>Returns</p> <p><code>1</code> (true) if the array is full (<code>array-&gt;top &gt;= array-&gt;cap</code>), <code>0</code> (false) otherwise.</p> <p>See Also</p> <ul> <li><code>ee_array_grow()</code></li> <li><code>ee_array_push()</code></li> </ul> EE_INLINE int ee_array_empty(const Array* array) <p></p> <p>Syntax</p> <pre><code>int ee_array_empty(const Array* array);\n</code></pre> <p>Description</p> <p>Checks if the array contains any elements.</p> <p>Parameters</p> Name Type Description <code>array</code> <code>const Array*</code> Pointer to the <code>Array</code> to check for emptiness. <p>Returns</p> <p><code>1</code> (true) if the array is empty (<code>array-&gt;top == 0</code>), <code>0</code> (false) otherwise</p> EE_INLINE size_t ee_array_len(const Array* array) <p></p> <p>Syntax</p> <pre><code>size_t ee_array_len(const Array* array);\n</code></pre> <p>Description</p> <p>Gets the number of elements currently stored in the array.</p> <p>Parameters</p> Name Type Description <code>array</code> <code>const Array*</code> Pointer to the <code>Array</code> to query for its element count. <p>Returns</p> <p>The element count (i.e., <code>array-&gt;top / array-&gt;elem_size</code>).</p> <p>See Also</p> <ul> <li><code>ee_array_size()</code> (for byte size)</li> </ul> EE_INLINE size_t ee_array_size(const Array* array) <p></p> <p>Syntax</p> <pre><code>size_t ee_array_size(const Array* array);\n</code></pre> <p>Description</p> <p>Gets the total number of bytes currently used by the stored elements. This is equivalent to <code>array-&gt;top</code>.</p> <p>Parameters</p> Name Type Description <code>array</code> <code>const Array*</code> Pointer to the <code>Array</code> to query for its used byte size. <p>Returns</p> <p>The used size in bytes (i.e., <code>array-&gt;top</code>).</p> <p>See Also</p> <ul> <li><code>ee_array_len()</code> (for element count)</li> </ul> EE_INLINE void ee_array_reserve(Array* array, size_t size) <p></p> <p>Syntax</p> <pre><code>void ee_array_reserve(Array* array, size_t size);\n</code></pre> <p>Description</p> <p>Reallocates the array's buffer to ensure it can hold at least <code>size</code> elements.</p> <p>This function asserts if the new <code>size</code> (in elements) is not larger than the current capacity.</p> <p>Note</p> <p>Based on the code's assertion (<code>size * array-&gt;elem_size &gt; array-&gt;cap</code>), this function can only be used to increase the capacity. It cannot be used to shrink the array.</p> <p>Parameters</p> Name Type Description <code>array</code> <code>Array*</code> Pointer to the <code>Array</code> to be resized. <code>size</code> <code>size_t</code> The desired new minimum element capacity (not bytes). EE_INLINE void ee_array_grow(Array* array) <p></p> <p>Syntax</p> <pre><code>void ee_array_grow(Array* array);\n</code></pre> <p>Description</p> <p>Grows the array's capacity by a factor of 1.5x (i.e., <code>new_cap = cap + (cap &gt;&gt; 1)</code>).</p> <p>This function is called automatically by <code>ee_array_push</code> and other modifiers when the array is full.</p> <p>Parameters</p> Name Type Description <code>array</code> <code>Array*</code> Pointer to the <code>Array</code> to be grown. <p>See Also</p> <ul> <li><code>ee_array_push()</code></li> <li><code>ee_array_full()</code></li> </ul>"},{"location":"headers/Array/array/#functions-element-access","title":"Functions (Element Access)","text":"EE_INLINE u8* ee_array_at(const Array* array, size_t i) <p>Syntax</p> <pre><code>u8* ee_array_at(const Array* array, size_t i);\n</code></pre> <p>Description</p> <p>Gets a direct, raw pointer to the element at the specified element index <code>i</code>.</p> <p>Important</p> <p>The returned pointer is a <code>u8*</code>. It is the user's responsibility to cast this pointer to the correct type. Use the <code>EE_ARRAY_RECAST</code> macro for a safer and cleaner way to do this.</p> <p>Parameters</p> Name Type Description <code>array</code> <code>const Array*</code> Pointer to the <code>Array</code> to access. <code>i</code> <code>size_t</code> The element index (not byte offset) to access. Asserts if out of bounds. <p>Returns</p> <p>A <code>u8*</code> pointer to the first byte of the element at index <code>i</code>.</p> <p>Example</p> <pre><code>// Using the macro (Recommended)\nint* my_int_ptr = EE_ARRAY_RECAST(&amp;int_array, 2, int);\n*my_int_ptr = 100; // Modify the value in-place\n\n// Using raw access (Manual casting)\nint* raw_ptr = (int*)ee_array_at(&amp;int_array, 2);\nprintf(\"Value: %d\\n\", *raw_ptr); // Prints 100\n</code></pre> <p>See Also</p> <ul> <li><code>ee_array_set()</code></li> <li><code>ee_array_top()</code></li> </ul> EE_INLINE u8* ee_array_top(const Array* array) <p></p> <p>Syntax</p> <pre><code>u8* ee_array_top(const Array* array);\n</code></pre> <p>Description</p> <p>Gets a direct, raw pointer to the last valid element in the array.</p> <p>Parameters</p> Name Type Description <code>array</code> <code>const Array*</code> Pointer to the <code>Array</code> to get the top element from. <p>Returns</p> <p>A <code>u8*</code> pointer to the last element, or <code>NULL</code> if the array is empty.</p> <p>Example</p> <pre><code>// Assumes 'int_array' is not empty\nint* last_val = (int*)ee_array_top(&amp;int_array);\nif (last_val) \n{\n    printf(\"Last element: %d\\n\", *last_val);\n}\n</code></pre> <p>See Also</p> <ul> <li><code>ee_array_at()</code></li> <li><code>ee_array_pop()</code></li> </ul>"},{"location":"headers/Array/array/#functions-modifiers","title":"Functions (Modifiers)","text":"EE_INLINE void ee_array_push(Array* array, const u8* val) <p>Syntax</p> <pre><code>void ee_array_push(Array* array, const u8* val);\n</code></pre> <p>Description</p> <p>Appends a new element to the end of the array by copying the data from <code>val</code>.</p> <p>If the array is full (<code>ee_array_full()</code> is <code>true</code>), this function will automatically call <code>ee_array_grow()</code> to expand the capacity before pushing the new element.</p> <p>Parameters</p> Name Type Description <code>array</code> <code>Array*</code> Pointer to the <code>Array</code> to push onto. <code>val</code> <code>const u8*</code> A pointer to the element data to be copied into the array. <p>Example</p> <pre><code>// Assumes 'int_array' is an Array with elem_size = sizeof(int)\nint x = 123;\nee_array_push(&amp;int_array, (const u8*)&amp;x);\n\n// Assumes 'struct_array' is an Array with elem_size = sizeof(MyStruct)\nMyStruct s = { .a = 1, .b = 2 };\nee_array_push(&amp;struct_array, (const u8*)&amp;s);\n</code></pre> <p>See Also</p> <ul> <li><code>ee_array_grow()</code></li> <li><code>ee_array_push_zero()</code></li> <li><code>ee_array_emplace()</code></li> </ul> EE_INLINE void ee_array_push_zero(Array* array) <p></p> <p>Syntax</p> <pre><code>void ee_array_push_zero(Array* array);\n</code></pre> <p>Description</p> <p>Appends a new, zero-initialized element to the end of the array.</p> <p>Calls <code>ee_array_grow()</code> if the array is full. This is useful for reserving an element and ensuring it has a clean default state.</p> <p>Parameters</p> Name Type Description <code>array</code> <code>Array*</code> Pointer to the <code>Array</code> to push onto. <p>See Also</p> <ul> <li><code>ee_array_push()</code></li> <li><code>ee_array_emplace()</code></li> </ul> EE_INLINE void ee_array_push_nothing(Array* array) <p></p> <p>Syntax</p> <pre><code>void ee_array_push_nothing(Array* array);\n</code></pre> <p>Description</p> <p>Advances the array's <code>top</code> pointer by one <code>elem_size</code>, effectively reserving space for a new element without initializing its memory.</p> <p>Calls <code>ee_array_grow()</code> if the array is full.</p> <p>Note</p> <p>This function is generally discouraged. Prefer <code>ee_array_emplace()</code>, which does the same thing but also returns a pointer to the newly reserved space.</p> <p>Parameters</p> Name Type Description <code>array</code> <code>Array*</code> Pointer to the <code>Array</code> to advance its <code>top</code> pointer. <p>See Also</p> <ul> <li><code>ee_array_emplace()</code></li> <li><code>ee_array_push()</code></li> </ul> EE_INLINE u8* ee_array_emplace(Array* array) <p></p> <p>Syntax</p> <pre><code>u8* ee_array_emplace(Array* array);\n</code></pre> <p>Description</p> <p>Appends space for one new element and returns a direct pointer to that new slot.</p> <p>This is the preferred way to add a new element if you want to initialize it in-place without a separate <code>memcpy</code> (which <code>ee_array_push()</code> does).</p> <p>Calls <code>ee_array_grow()</code> if the array is full.</p> <p>Note</p> <p>This function returns a pointer to the beginning of the new element's slot; the memory at that location is uninitialized.</p> <p>Parameters</p> Name Type Description <code>array</code> <code>Array*</code> Pointer to the <code>Array</code> to emplace into. <p>Returns</p> <p>A <code>u8*</code> pointer to the newly reserved (but uninitialized) element slot.</p> <p>Example</p> <pre><code>// Emplace a new int and initialize it\nint* new_int = (int*)ee_array_emplace(&amp;int_array);\n*new_int = 42;\n\n// Emplace a new struct and initialize it\nMyStruct* new_s = (MyStruct*)ee_array_emplace(&amp;struct_array);\nnew_s-&gt;name = \"Example\";\nnew_s-&gt;id = 123;\n\n// Array now contains the fully initialized struct\n</code></pre> <p>See Also</p> <ul> <li><code>ee_array_push()</code> (alternative that takes a pointer to data)</li> <li><code>ee_array_push_nothing()</code> (discouraged alternative)</li> </ul> EE_INLINE void ee_array_pop(Array* array, u8* out_val) <p></p> <p>Syntax</p> <pre><code>void ee_array_pop(Array* array, u8* out_val);\n</code></pre> <p>Description</p> <p>Removes the last element from the array by decrementing the <code>top</code> pointer.</p> <p>If <code>out_val</code> is not <code>NULL</code>, the element's data is copied into <code>out_val</code> before it is \"removed\" (i.e., before <code>top</code> is moved).</p> <p>Parameters</p> Name Type Description <code>array</code> <code>Array*</code> Pointer to the <code>Array</code> to pop from. Asserts if empty. <code>out_val</code> <code>u8*</code> Optional. A pointer to a destination buffer to copy the popped element into. Pass <code>NULL</code> to discard the element. <p>Example</p> <pre><code>int last_val;\n// Pop the last int and store it in last_val\nee_array_pop(&amp;int_array, (u8*)&amp;last_val);\n\n// Pop the last element and discard it\nee_array_pop(&amp;int_array, NULL);\n</code></pre> <p>See Also</p> <ul> <li><code>ee_array_push()</code></li> <li><code>ee_array_top()</code></li> </ul> EE_INLINE void ee_array_set(Array* array, size_t i, const u8* val) <p></p> <p>Syntax</p> <pre><code>void ee_array_set(Array* array, size_t i, const u8* val);\n</code></pre> <p>Description</p> <p>Overwrites the element at the specified index <code>i</code> by copying new data from <code>val</code>.</p> <p>Parameters</p> Name Type Description <code>array</code> <code>Array*</code> Pointer to the <code>Array</code> to modify. <code>i</code> <code>size_t</code> The element index to modify. Asserts if out of bounds. <code>val</code> <code>const u8*</code> A pointer to the new element data to be copied into the array. <p>Example</p> <pre><code>int new_val = 777;\n// Set the element at index 3 to 777\nee_array_set(&amp;int_array, 3, (EE_RECAST_U8)new_val);\n</code></pre> <p>See Also</p> <ul> <li><code>ee_array_at()</code></li> </ul> EE_INLINE void ee_array_insert(Array* array, size_t i, const u8* val) <p></p> <p>Syntax</p> <pre><code>void ee_array_insert(Array* array, size_t i, const u8* val);\n</code></pre> <p>Description</p> <p>Inserts an element at index <code>i</code>, shifting all subsequent elements one position to the right.</p> <p>If the array is full, it will be grown via <code>ee_array_grow()</code> before the insertion.</p> <p>Performance</p> <p>This is an O(n) operation (slow for large arrays) because it uses <code>memmove</code> to shift all elements after index <code>i</code>.</p> <p>Parameters</p> Name Type Description <code>array</code> <code>Array*</code> Pointer to the <code>Array</code> to insert into. <code>i</code> <code>size_t</code> The element index at which to insert. Asserts if <code>i &gt; ee_array_len()</code>. <code>val</code> <code>const u8*</code> A pointer to the new element data to be copied into the array. <p>See Also</p> <ul> <li><code>ee_array_push()</code> (for O(1) insertion at the end)</li> <li><code>ee_array_erase()</code></li> </ul> EE_INLINE void ee_array_erase(Array* array, size_t i) <p></p> <p>Syntax</p> <pre><code>void ee_array_erase(Array* array, size_t i);\n</code></pre> <p>Description</p> <p>Removes the element at index <code>i</code>, shifting all subsequent elements one position to the left to fill the gap.</p> <p>Important</p> <p>This is an O(n) operation (slow for large arrays) because it uses <code>memmove</code> to shift all elements after index <code>i</code>.</p> <p>Fast Unordered Erase</p> <p>If you need to remove an element and do not care about preserving the order of the array, use <code>ee_array_swap_n_pop()</code> instead. It runs in O(1) time.</p> <p>Parameters</p> Name Type Description <code>array</code> <code>Array*</code> Pointer to the <code>Array</code> to erase from. <code>i</code> <code>size_t</code> The element index to remove. Asserts if out of bounds. <p>See Also</p> <ul> <li><code>ee_array_swap_n_pop()</code> (Fast O(1) alternative)</li> <li><code>ee_array_pop()</code></li> <li><code>ee_array_clear()</code></li> </ul> EE_INLINE void ee_array_swap(Array* array, size_t i, size_t j) <p></p> <p>Syntax</p> <pre><code>void ee_array_swap(Array* array, size_t i, size_t j);\n</code></pre> <p>Description</p> <p>Swaps the elements at index <code>i</code> and index <code>j</code> in-place.</p> <p>This function uses <code>EE_ALLOCA</code> to allocate a temporary buffer on the stack for the swap.</p> <p>Parameters</p> Name Type Description <code>array</code> <code>Array*</code> Pointer to the <code>Array</code> to modify. * <code>i</code> <code>size_t</code> The element index of the first element. <code>j</code> <code>size_t</code> The element index of the second element. <p>See Also</p> <ul> <li><code>ee_array_sort()</code></li> </ul> EE_INLINE void ee_array_swap_n_pop(Array* array, size_t i, u8* out_val) <p></p> <p>Syntax</p> <pre><code>void ee_array_swap_n_pop(Array* array, size_t i, u8* out_val);\n</code></pre> <p>Description</p> <p>Removes the element at index <code>i</code> by overwriting it with the last element in the array, and then decrementing the <code>top</code> pointer.</p> <p>This is an extremely fast O(1) removal operation.</p> <p>Important</p> <p>This function will break the order of your array if the removed element is not the last element. Use <code>ee_array_erase()</code> if you need to preserve the order of other elements (which is a slow O(n) operation).</p> <p>Parameters</p> Name Type Description <code>array</code> <code>Array*</code> Pointer to the <code>Array</code> to modify. <code>i</code> <code>size_t</code> The element index to remove. Asserts if out of bounds. <code>out_val</code> <code>u8*</code> Optional. A pointer to a destination buffer to copy the original element at index <code>i</code> before it is overwritten. Pass <code>NULL</code> to discard. <p>Example</p> <pre><code>// Array content: [10, 20, 30, 40, 50]\n// We want to remove index 1 (value 20)\n\nint removed_val;\nee_array_swap_n_pop(&amp;int_array, 1, (u8*)&amp;removed_val);\n\n// removed_val is now 20\n// Array content is now: [10, 50, 30, 40]\n// (Note that 50 moved to index 1, and 20 is gone)\n</code></pre> <p>See Also</p> <ul> <li><code>ee_array_erase()</code> (Slow, order-preserving alternative)</li> <li><code>ee_array_pop()</code></li> </ul> EE_INLINE void ee_array_fill(Array* array, const u8* val, size_t a, size_t b) <p></p> <p>Syntax</p> <pre><code>void ee_array_fill(Array* array, const u8* val, size_t a, size_t b);\n</code></pre> <p>Description</p> <p>Fills a range of the array <code>[a, b)</code> with copies of the element data from <code>val</code>.</p> <p>This function iterates from the element index <code>a</code> up to (but not including) <code>b</code>, copying the data from <code>val</code> into each slot.</p> <p>Note</p> <p>This function operates within the array's capacity (<code>cap</code>). If the fill range <code>b</code> extends beyond the current array size <code>top</code>, <code>top</code> will be updated to <code>b * elem_size</code>. This allows <code>ee_array_fill</code> to be used to initialize portions of the array's reserved capacity.</p> <p>Parameters</p> Name Type Description <code>array</code> <code>Array*</code> Pointer to the <code>Array</code> to be filled. <code>val</code> <code>const u8*</code> A pointer to the element data that will be copied into each slot in the range. <code>a</code> <code>size_t</code> The starting element index (inclusive) of the range to fill. <code>b</code> <code>size_t</code> The ending element index (exclusive) of the range to fill. Asserts if <code>a &gt;= b</code> or range is outside the capacity. <p>Example</p> <pre><code>// Create an array with capacity for 10 ints, but size 0\nArray int_array = ee_array_new(10, sizeof(int), NULL);\n\nint val_a = 7;\n// Fill the first 5 elements with '7'.\n// This also sets ee_array_len() to 5.\nee_array_fill(&amp;int_array, (u8*)&amp;val_a, 0, 5);\n\n// ee_array_len(&amp;int_array) is now 5\n\nint val_b = -1;\n// Overwrite elements at index 2 and 3 with '-1'\nee_array_fill(&amp;int_array, (u8*)&amp;val_b, 2, 4);\n\n// Array content: [7, 7, -1, -1, 7]\n</code></pre> <p>See Also</p> <ul> <li><code>ee_array_set()</code></li> <li><code>ee_array_clear()</code></li> </ul> EE_INLINE void ee_array_reverse(Array* array) <p></p> <p>Syntax</p> <pre><code>void ee_array_reverse(Array* array);\n</code></pre> <p>Description</p> <p>Reverses the order of all elements in the array in-place.</p> <p>It works by iterating from the start to the middle of the array (<code>len / 2</code>) and swapping each element <code>i</code> with its counterpart <code>len - 1 - i</code>.</p> <p>Parameters</p> Name Type Description <code>array</code> <code>Array*</code> Pointer to the <code>Array</code> to be reversed. <p>Example</p> <pre><code>// Array content: [10, 20, 30, 40]\nee_array_reverse(&amp;int_array);\n// Array content is now: [40, 30, 20, 10]\n</code></pre> <p>See Also</p> <ul> <li><code>ee_array_swap()</code></li> </ul> EE_INLINE void ee_array_clear(Array* array) <p></p> <p>Syntax</p> <pre><code>void ee_array_clear(Array* array);\n</code></pre> <p>Description</p> <p>Removes all elements from the array by setting its <code>top</code> (byte count) to <code>0</code>.</p> <p>Important</p> <p>This function does not free or zero the underlying memory buffer. It only resets the element count, allowing the buffer to be reused.</p> <p>Parameters</p> Name Type Description <code>array</code> <code>Array*</code> Pointer to the <code>Array</code> to be cleared. <p>See Also</p> <ul> <li><code>ee_array_reset()</code></li> <li><code>ee_array_free()</code></li> </ul> EE_INLINE void ee_array_reset(Array* array) <p></p> <p>Syntax</p> <pre><code>void ee_array_reset(Array* array);\n</code></pre> <p>Description</p> <p>Resets the array's element count to zero by setting <code>top = 0</code>. This is identical in function to <code>ee_array_clear()</code>.</p> <p>Important</p> <p>This function does not free or zero the underlying memory buffer. It only resets the element count, allowing the buffer to be reused.</p> <p>Parameters</p> Name Type Description <code>array</code> <code>Array*</code> Pointer to the <code>Array</code> to be reset. <p>See Also</p> <ul> <li><code>ee_array_clear()</code></li> <li><code>ee_array_free()</code></li> </ul>"},{"location":"headers/Array/array/#functions-search","title":"Functions (Search)","text":"EE_INLINE size_t ee_array_find(const Array* array, const u8* target) <p>Syntax</p> <pre><code>size_t ee_array_find(const Array* array, const u8* target);\n</code></pre> <p>Description</p> <p>Finds the first occurrence of <code>target</code> in the entire array.</p> <p>This is a convenience wrapper for <code>ee_array_find_b(array, target, 0, ee_array_len(array))</code>. It benefits from the same SIMD optimizations as <code>ee_array_find_b</code>.</p> <p>Parameters</p> Name Type Description <code>array</code> <code>const Array*</code> Pointer to the <code>Array</code> to be searched. <code>target</code> <code>const u8*</code> A pointer to the element data to search for. <p>Returns</p> <p>The index of the first matching element, or <code>EE_ARRAY_INVALID</code> if not found.</p> <p>See Also</p> <ul> <li><code>ee_array_find_b()</code></li> <li><code>ee_array_find_pred()</code></li> </ul> EE_INLINE size_t ee_array_find_b(const Array* array, const u8* target, size_t low, size_t high) <p></p> <p>Syntax</p> <pre><code>size_t ee_array_find_b(const Array* array, const u8* target, size_t low, size_t high);\n</code></pre> <p>Description</p> <p>Finds the first occurrence of <code>target</code> within the element index range <code>[low, high)</code>.</p> <p>This function is heavily optimized using SIMD instructions for element sizes of 1, 2, 4, and 8 bytes. It performs the search in three phases:</p> <ol> <li>Head: Linearly checks unaligned elements from <code>low</code> up to the first SIMD-aligned boundary.</li> <li>Body: Scans the main, aligned portion of the array in large (e.g., 16/32-byte) SIMD chunks.</li> <li>Tail: Linearly checks any remaining elements after the last aligned chunk up to <code>high</code>.</li> </ol> <p>For all other <code>elem_size</code> values, it falls back to a standard <code>memcmp</code> loop.</p> <p>Parameters</p> Name Type Description <code>array</code> <code>const Array*</code> Pointer to the <code>Array</code> to be searched. <code>target</code> <code>const u8*</code> A pointer to the element data to search for. <code>low</code> <code>size_t</code> The starting element index (inclusive). <code>high</code> <code>size_t</code> The ending element index (exclusive). Asserts if <code>low &gt;= high</code>. <p>Returns</p> <p>The index of the first matching element, or <code>EE_ARRAY_INVALID</code> if not found.</p> <p>See Also</p> <ul> <li><code>ee_array_find()</code> (wrapper for this function)</li> <li><code>ee_array_find_pred_b()</code></li> </ul> EE_INLINE size_t ee_array_find_pred(const Array* array, const u8* target, BinCmp predicate) <p></p> <p>Syntax</p> <pre><code>size_t ee_array_find_pred(const Array* array, const u8* target, BinCmp predicate);\n</code></pre> <p>Description</p> <p>Finds the first element in the entire array that matches <code>target</code> according to a custom <code>predicate</code> function.</p> <p>This is a convenience wrapper for <code>ee_array_find_pred_b(array, target, predicate, 0, ee_array_len(array))</code>.</p> <p>Parameters</p> Name Type Description <code>array</code> <code>const Array*</code> Pointer to the <code>Array</code> to be searched. <code>target</code> <code>const u8*</code> A pointer to the data to compare against. This is passed as the first argument to <code>predicate</code>. <code>predicate</code> <code>BinCmp</code> A function pointer (<code>int (*)(const void*, const void*)</code>). The function should return <code>0</code> for a match. <p>Returns</p> <p>The index of the first matching element, or <code>EE_ARRAY_INVALID</code> if not found.</p> EE_INLINE size_t ee_array_find_pred_b(const Array* array, const u8* target, BinCmp predicate, size_t low, size_t high) <p></p> <p>Syntax</p> <pre><code>size_t ee_array_find_pred_b(const Array* array, const u8* target, BinCmp predicate, size_t low, size_t high);\n</code></pre> <p>Description</p> <p>Finds the first element in the index range <code>[low, high)</code> that matches <code>target</code> according to a custom <code>predicate</code> function.</p> <p>The search stops at the first element where <code>predicate(target, element)</code> returns <code>0</code>.</p> <p>Parameters</p> Name Type Description <code>array</code> <code>const Array*</code> Pointer to the <code>Array</code> to be searched. <code>target</code> <code>const u8*</code> A pointer to the data to compare against. This is passed as the first argument to <code>predicate</code>. <code>predicate</code> <code>BinCmp</code> A function pointer (<code>int (*)(const void*, const void*)</code>). The function should return <code>0</code> for a match. <code>low</code> <code>size_t</code> The starting element index (inclusive). <code>high</code> <code>size_t</code> The ending element index (exclusive). Asserts if <code>low &gt;= high</code>. <p>Returns</p> <p>The index of the first matching element, or <code>EE_ARRAY_INVALID</code> if not found.</p> <p>See Also</p> <ul> <li><code>ee_array_find_pred()</code></li> <li><code>ee_array_find_b()</code></li> </ul> EE_INLINE size_t ee_array_min_pred(const Array* array, BinCmp predicate) <p></p> <p>Syntax</p> <pre><code>size_t ee_array_min_pred(const Array* array, BinCmp predicate);\n</code></pre> <p>Description</p> <p>Finds the index of the minimum element in the entire array, according to a <code>predicate</code>.</p> <p>This is a convenience wrapper for <code>ee_array_min_pred_b(array, predicate, 0, ee_array_len(array))</code>.</p> <p>Parameters</p> Name Type Description <code>array</code> <code>const Array*</code> Pointer to the <code>Array</code> to be searched. <code>predicate</code> <code>BinCmp</code> The comparison function. It should return <code>&lt; 0</code> if the first argument is \"less than\" the second. <p>Returns</p> <p>The index of the minimum element.</p> <p>See Also</p> <ul> <li><code>ee_array_min_pred_b()</code></li> <li><code>ee_array_max_pred()</code></li> </ul> EE_INLINE size_t ee_array_min_pred_b(const Array* array, BinCmp predicate, size_t low, size_t high) <p></p> <p>Syntax</p> <pre><code>size_t ee_array_min_pred_b(const Array* array, BinCmp predicate, size_t low, size_t high);\n</code></pre> <p>Description</p> <p>Finds the index of the minimum element within the index range <code>[low, high)</code>.</p> <p>The comparison is performed by the <code>predicate</code> function. An element <code>i</code> is considered the new minimum if <code>predicate(element_i, current_min)</code> returns <code>&lt; 0</code>.</p> <p>Parameters</p> Name Type Description <code>array</code> <code>const Array*</code> Pointer to the <code>Array</code> to be searched. <code>predicate</code> <code>BinCmp</code> The comparison function. It should return <code>&lt; 0</code> if the first argument is \"less than\" the second. <code>low</code> <code>size_t</code> The starting element index (inclusive). <code>high</code> <code>size_t</code> The ending element index (exclusive). Asserts if <code>low &gt;= high</code>. <p>Returns</p> <p>The index of the minimum element found in the range. (Returns <code>low</code> if the range contains only one element).</p> <p>See Also</p> <ul> <li><code>ee_array_max_pred_b()</code></li> <li><code>ee_array_sort()</code></li> </ul> EE_INLINE size_t ee_array_max_pred(const Array* array, BinCmp predicate) <p></p> <p>Syntax</p> <pre><code>size_t ee_array_max_pred(const Array* array, BinCmp predicate);\n</code></pre> <p>Description</p> <p>Finds the index of the maximum element in the entire array, according to a <code>predicate</code>.</p> <p>This is a convenience wrapper for <code>ee_array_max_pred_b(array, predicate, 0, ee_array_len(array))</code>.</p> <p>Parameters</p> Name Type Description <code>array</code> <code>const Array*</code> Pointer to the <code>Array</code> to be searched. <code>predicate</code> <code>BinCmp</code> The comparison function. It should return <code>&gt; 0</code> if the first argument is \"greater than\" the second. <p>Returns</p> <p>The index of the maximum element.</p> <p>See Also</p> <ul> <li><code>ee_array_max_pred_b()</code></li> <li><code>ee_array_min_pred()</code></li> </ul> EE_INLINE size_t ee_array_max_pred_b(const Array* array, BinCmp predicate, size_t low, size_t high) <p></p> <p>Syntax</p> <pre><code>size_t ee_array_max_pred_b(const Array* array, BinCmp predicate, size_t low, size_t high);\n</code></pre> <p>Description</p> <p>Finds the index of the maximum element within the index range <code>[low, high)</code>.</p> <p>The comparison is performed by the <code>predicate</code> function. An element <code>i</code> is considered the new maximum if <code>predicate(element_i, current_max)</code> returns <code>&gt; 0</code>.</p> <p>Parameters</p> Name Type Description <code>array</code> <code>const Array*</code> Pointer to the <code>Array</code> to be searched. <code>predicate</code> <code>BinCmp</code> The comparison function. It should return <code>&gt; 0</code> if the first argument is \"greater than\" the second. <code>low</code> <code>size_t</code> The starting element index (inclusive). <code>high</code> <code>size_t</code> The ending element index (exclusive). Asserts if <code>low &gt;= high</code>. <p>Returns</p> <p>The index of the maximum element found in the range. (Returns <code>low</code> if the range contains only one element).</p> <p>See Also</p> <ul> <li><code>ee_array_min_pred_b()</code></li> <li><code>ee_array_sort()</code></li> </ul>"},{"location":"headers/Array/array/#functions-sorting","title":"Functions (Sorting)","text":"EE_INLINE void ee_array_sort(Array* array, BinCmp cmp, ArraySortType type) <p>Syntax</p> <pre><code>void ee_array_sort(Array* array, BinCmp cmp, ArraySortType type);\n</code></pre> <p>Description</p> <p>Sorts the entire array in-place using the specified algorithm and comparison function.</p> <p>This is the main, user-facing sort function. It acts as a wrapper that calls the appropriate low-level sorting implementation (e.g., <code>ee_array_introsort()</code>), handling the conversion from element indices to the byte offsets required by the internal functions.</p> <p>Parameters</p> Name Type Description <code>array</code> <code>Array*</code> Pointer to the <code>Array</code> to be sorted. <code>cmp</code> <code>BinCmp</code> The comparison function <code>int (*)(const void* a, const void* b)</code>. It must return: \u2022 <code>&lt; 0</code> if <code>a &lt; b</code> \u2022 <code>0</code> if <code>a == b</code> \u2022 <code>&gt; 0</code> if <code>a &gt; b</code> <code>type</code> <code>ArraySortType</code> The sorting algorithm to use. <code>EE_SORT_DEFAULT</code> (Introsort) is highly recommended for most cases. <p>Example</p> <pre><code>// 1. Define an Array of integers\nArray int_array = ee_array_new(10, sizeof(int), NULL);\n// ... (push some integers into the array) ...\n\n// 2. Define a comparison function (BinCmp) for integers\nint compare_ints(const void* a, const void* b) \n{\n    int val_a = *(const int*)a;\n    int val_b = *(const int*)b;\n\n    // Return (a &gt; b) - (a &lt; b) for a simple, fast comparison\n    return (val_a &gt; val_b) - (val_a &lt; val_b);\n\n    /* // A more verbose but equivalent way:\n    if (val_a &lt; val_b) return -1;\n    if (val_a &gt; val_b) return 1;\n    return 0;\n    */\n}\n\n// 3. Call the sort function\nee_array_sort(&amp;int_array, compare_ints, EE_SORT_DEFAULT);\n\n// ... int_array is now sorted ...\n</code></pre> <p>See Also</p> <ul> <li><code>ArraySortType</code> (enum)</li> <li><code>ee_array_introsort()</code></li> <li><code>ee_array_heapsort()</code></li> <li><code>ee_array_quicksort()</code></li> <li><code>ee_array_insertsort()</code></li> </ul>"},{"location":"headers/Array/array/#internal-sort-implementations","title":"Internal Sort Implementations","text":"<p>These functions are low-level helpers called by <code>ee_array_sort()</code>.</p> <p>Note</p> <p>For most use cases, calling the main <code>ee_array_sort()</code> function is highly recommended, as it operates on element indices.</p> <p>The functions in this section are low-level helpers. They expect their <code>low</code> and <code>high</code> range parameters as byte offsets, which can be less intuitive and error-prone if used directly.</p> EE_INLINE void ee_array_insertsort(Array* array, BinCmp cmp, i64 low, i64 high) <p></p> <p>Syntax</p> <pre><code>void ee_array_insertsort(Array* array, BinCmp cmp, i64 low, i64 high);\n</code></pre> <p>Description</p> <p>Sorts a sub-section of the array using the Insertion Sort algorithm.</p> <p>Insertion sort iterates through the array, taking one element at a time and inserting it into its correct position within the already-sorted portion of the array.</p> <p>This algorithm is O(n<sup>2</sup>) but is very efficient for small arrays (see <code>EE_ARRAY_SORT_TH</code>) or for arrays that are already mostly sorted. It is used as the final step in <code>ee_array_introsort</code>.</p> <p>Parameters</p> Name Type Description <code>array</code> <code>Array*</code> Pointer to the <code>Array</code> to be sorted. <code>cmp</code> <code>BinCmp</code> The comparison function. Must return <code>&lt; 0</code> if <code>a &lt; b</code>, <code>0</code> if <code>a == b</code>, or <code>&gt; 0</code> if <code>a &gt; b</code>. <code>low</code> <code>i64</code> The byte offset of the first element in the range (inclusive). <code>high</code> <code>i64</code> The byte offset of the last element in the range (inclusive). <p>See Also</p> <ul> <li><code>ee_array_sort()</code></li> <li><code>ee_array_introsort()</code></li> </ul> EE_INLINE void ee_array_quicksort(Array* array, BinCmp cmp, i64 low, i64 high) <p></p> <p>Syntax</p> <pre><code>void ee_array_quicksort(Array* array, BinCmp cmp, i64 low, i64 high);\n</code></pre> <p>Description</p> <p>Sorts a sub-section of the array using the Quicksort algorithm.</p> <p>Quicksort is a divide-and-conquer algorithm. This implementation works as follows: 1.  Selects the middle element as the \"pivot\". 2.  Partitions the array (using a Hoare-like scheme) so that all elements smaller than the pivot are to its left, and all elements larger are to its right. 3.  Recursively calls itself on the two sub-arrays (partitions).</p> <p>This algorithm has an average-case performance of O(n log n), but a worst-case performance of O(n<sup>2</sup>), which <code>ee_array_introsort</code> is designed to prevent.</p> <p>Parameters</p> Name Type Description <code>array</code> <code>Array*</code> Pointer to the <code>Array</code> to be sorted. <code>cmp</code> <code>BinCmp</code> The comparison function. Must return <code>&lt; 0</code> if <code>a &lt; b</code>, <code>0</code> if <code>a == b</code>, or <code>&gt; 0</code> if <code>a &gt; b</code>. <code>low</code> <code>i64</code> The byte offset of the first element in the range (inclusive). <code>high</code> <code>i64</code> The byte offset of the last element in the range (inclusive). <p>See Also</p> <ul> <li><code>ee_array_sort()</code></li> <li><code>ee_array_introsort()</code></li> </ul> EE_INLINE void ee_array_heapsort(Array* array, BinCmp cmp, i64 low, i64 high) <p></p> <p>Syntax</p> <pre><code>void ee_array_heapsort(Array* array, BinCmp cmp, i64 low, i64 high);\n</code></pre> <p>Description</p> <p>Sorts a sub-section of the array using the Heapsort algorithm.</p> <p>Heapsort is an in-place, comparison-based algorithm that works in two phases: 1.  Build Max-Heap: It first rearranges the array into a \"max-heap\", which is a binary tree structure (represented linearly in the array) where every parent node is larger than or equal to its children.</p> <ol> <li>Sortdown: It repeatedly swaps the root element (the largest item) with the last element in the heap, reduces the heap's size by one, and \"sifts down\" the new root to maintain the max-heap property.</li> </ol> <p>This algorithm has a guaranteed worst-case and average-case performance of O(n log n). It is used by <code>ee_array_introsort</code> to avoid the O(n<sup>2</sup>) worst-case of Quicksort when the recursion depth becomes too large.</p> <p>Parameters</p> Name Type Description <code>array</code> <code>Array*</code> Pointer to the <code>Array</code> to be sorted. <code>cmp</code> <code>BinCmp</code> The comparison function. Must return <code>&lt; 0</code> if <code>a &lt; b</code>, <code>0</code> if <code>a == b</code>, or <code>&gt; 0</code> if <code>a &gt; b</code>. <code>low</code> <code>i64</code> The byte offset of the first element in the range (inclusive). <code>high</code> <code>i64</code> The byte offset of the last element in the range (inclusive). <p>See Also</p> <ul> <li><code>ee_array_sort()</code></li> <li><code>ee_array_introsort()</code></li> </ul> EE_INLINE void ee_array_introsort(Array* array, BinCmp cmp, i64 low, i64 high, i32 max_depth) <p></p> <p>Syntax</p> <pre><code>void ee_array_introsort(Array* array, BinCmp cmp, i64 low, i64 high, i32 max_depth);\n</code></pre> <p>Description</p> <p>Sorts a sub-section of the array using the Introspective Sort (Introsort) algorithm.</p> <p>Introsort is a hybrid algorithm that combines the speed of Quicksort with the guaranteed worst-case O(n log n) performance of Heapsort.</p> <p>This implementation's behavior depends on the partition size and recursion depth:</p> <ol> <li>Quicksort (Default): It begins by performing a standard Quicksort partition.</li> <li>Heapsort (Fallback): If the recursion <code>max_depth</code> (used to detect bad pivot choices) reaches zero, it switches to <code>ee_array_heapsort()</code> to prevent Quicksort's O(n<sup>2</sup>) worst-case.</li> <li>Insertion Sort (Base Case): If a partition's size (<code>len</code>) becomes smaller than or equal to <code>EE_ARRAY_SORT_TH</code>, it switches to <code>ee_array_insertsort()</code>, which is more efficient for small arrays.</li> </ol> <p>This hybrid approach provides a fast average-case sort while completely avoiding quadratic performance. It is the default algorithm used by <code>ee_array_sort()</code>.</p> <p>Parameters</p> Name Type Description <code>array</code> <code>Array*</code> Pointer to the <code>Array</code> to be sorted. <code>cmp</code> <code>BinCmp</code> The comparison function. Must return <code>&lt; 0</code> if <code>a &lt; b</code>, <code>0</code> if <code>a == b</code>, or <code>&gt; 0</code> if <code>a &gt; b</code>. <code>low</code> <code>i64</code> The byte offset of the first element in the range (inclusive). <code>high</code> <code>i64</code> The byte offset of the last element in the range (inclusive). <code>max_depth</code> <code>i32</code> The recursion depth limit. When this hits <code>0</code>, the algorithm switches to Heapsort. <p>See Also</p> <ul> <li><code>ee_array_sort()</code></li> <li><code>ee_array_quicksort()</code></li> <li><code>ee_array_heapsort()</code></li> <li><code>ee_array_insertsort()</code></li> </ul>"},{"location":"headers/Random/random/","title":"ee_random.h","text":"<p>In progress</p> <p>This documentation page is currently under development.</p> <p><code>ee_random.h</code> provides a pseudorandom number generator (PRNG) and functions for sampling from various distributions.</p> <p>The generator is based on the <code>xorshift128+</code> algorithm. The <code>Rng</code> context is initialized from a 64-bit seed using the <code>SplitMix64</code> algorithm. This module provides functions to generate uniformly distributed integers and floats, as well as normally distributed (Gaussian) floats.</p>"},{"location":"headers/Random/random/#defines","title":"Defines","text":"Macro Value Description <code>EE_RNG_STATE_LEN</code> <code>(2)</code> The number of 64-bit integers in the <code>Rng</code> state array. <code>EE_RNG_EPS</code> <code>(1e-16)</code> A small <code>f64</code> epsilon value used for numerical stability in the normal distribution generator (<code>ee_randn_f64</code>). <code>EE_RNG_EPSF</code> <code>(1e-12f)</code> A small <code>f32</code> epsilon value used for numerical stability in the normal distribution generator (<code>ee_randn_f32</code>). <code>EE_RNG_SEED_DEF</code> <code>(0xF23A9BC7...ull)</code> A default 64-bit seed constant."},{"location":"headers/Random/random/#structures","title":"Structures","text":"<p>  The context structure for the PRNG. It holds the internal state and a cached value for the normal distribution generator.</p> <pre><code>typedef struct Rng\n{\n    u64 state[EE_RNG_STATE_LEN];\n    f64 spare;\n    i32 have_spare;\n} Rng;\n</code></pre> Structure Members Members Type Description <code>state</code> <code>u64[2]</code> The internal 128-bit state of the <code>xorshift128+</code> generator. <code>spare</code> <code>f64</code> A cached <code>f64</code> value from the normal distribution generator, which produces two values at a time. <code>have_spare</code> <code>i32</code> A flag (0 or 1) indicating if the <code>spare</code> field contains a valid cached value."},{"location":"headers/Random/random/#functions-lifecycle","title":"Functions (Lifecycle)","text":"EE_INLINE Rng ee_rng_new(u64 seed) <p>Syntax</p> <pre><code>Rng ee_rng_new(u64 seed);\n</code></pre> <p>Description</p> <p>Initializes a new <code>Rng</code> context from a single 64-bit seed.</p> <p>It uses the <code>ee_splitmix_u64</code> algorithm to expand the seed into the 128-bit (2 x <code>u64</code>) internal state required by the <code>xorshift128+</code> generator.</p> <p>Parameters</p> Name Type Description <code>seed</code> <code>u64</code> The 64-bit value used to initialize the generator's state. <p>Returns</p> <p>An initialized <code>Rng</code> structure.</p> <p>Example</p> <pre><code>Rng my_rng = ee_rng_new(12345ull);\nu64 random_val = ee_rand_u64(&amp;my_rng);\n</code></pre>"},{"location":"headers/Random/random/#functions-uniform-distribution","title":"Functions (Uniform Distribution)","text":"<p>These functions generate uniformly distributed numbers.</p> EE_INLINE u64 ee_rand_u64(Rng* rng) <p></p> <p>Syntax</p> <pre><code>u64 ee_rand_u64(Rng* rng);\n</code></pre> <p>Description</p> <p>Generates the next raw <code>u64</code> random value from the <code>xorshift128+</code> algorithm and advances the internal state. This is the core generator function.</p> <p>Parameters</p> Name Type Description <code>rng</code> <code>Rng*</code> Pointer to the <code>Rng</code> context to be advanced. <p>Returns</p> <p>A 64-bit unsigned integer.</p> EE_INLINE u32 ee_rand_u32(Rng* rng) <p></p> <p>Syntax</p> <pre><code>u32 ee_rand_u32(Rng* rng);\n</code></pre> <p>Description</p> <p>Generates a <code>u32</code> random value by taking the upper 32 bits of a <code>u64</code> value from <code>ee_rand_u64()</code>.</p> <p>Parameters</p> Name Type Description <code>rng</code> <code>Rng*</code> Pointer to the <code>Rng</code> context. <p>Returns</p> <p>A 32-bit unsigned integer.</p> EE_INLINE f64 ee_rand_f64(Rng* rng) <p></p> <p>Syntax</p> <pre><code>f64 ee_rand_f64(Rng* rng);\n</code></pre> <p>Description</p> <p>Generates a <code>f64</code> random value in the range <code>[0.0, 1.0)</code>.</p> <p>It uses the upper 53 bits of <code>ee_rand_u64()</code> to provide full 53-bit precision for the <code>f64</code> mantissa.</p> <p>Parameters</p> Name Type Description <code>rng</code> <code>Rng*</code> Pointer to the <code>Rng</code> context. <p>Returns</p> <p>A <code>f64</code> value within the range <code>[0.0, 1.0)</code> (inclusive of 0.0 and exclusive of 1.0).</p> EE_INLINE f32 ee_rand_f32(Rng* rng) <p></p> <p>Syntax</p> <pre><code>f32 ee_rand_f32(Rng* rng);\n</code></pre> <p>Description</p> <p>Generates a <code>f32</code> random value in the range <code>[0.0, 1.0)</code>.</p> <p>It uses the upper 24 bits of <code>ee_rand_u32()</code> to provide full 24-bit precision for the <code>f32</code> mantissa.</p> <p>Parameters</p> Name Type Description <code>rng</code> <code>Rng*</code> Pointer to the <code>Rng</code> context. <p>Returns</p> <p>A <code>f32</code> value within the range <code>[0.0, 1.0)</code> (inclusive of 0.0 and exclusive of 1.0).</p>"},{"location":"headers/Random/random/#functions-bounded-distribution","title":"Functions (Bounded Distribution)","text":"<p>These functions generate uniformly distributed numbers within a specified range.</p> EE_INLINE u64 ee_rand_u64_b(Rng* rng, u64 bound) <p></p> <p>Syntax</p> <pre><code>u64 ee_rand_u64_b(Rng* rng, u64 bound);\n</code></pre> <p>Description</p> <p>Generates a <code>u64</code> random value in the range <code>[0, bound)</code>. The upper bound is exclusive.</p> <p>It uses a debiasing loop (the \"threshold\" method) to ensure a uniform distribution, even when <code>bound</code> is not a power of two.</p> <p>Parameters</p> Name Type Description <code>rng</code> <code>Rng*</code> Pointer to the <code>Rng</code> context. <code>bound</code> <code>u64</code> The exclusive upper bound. If <code>0</code>, the function returns <code>0</code>. <p>Returns</p> <p>A <code>u64</code> value within the range <code>[0, bound)</code> (inclusive of 0 and exclusive of <code>bound</code>).</p> EE_INLINE u32 ee_rand_u32_b(Rng* rng, u32 bound) <p></p> <p>Syntax</p> <pre><code>u32 ee_rand_u32_b(Rng* rng, u32 bound);\n</code></pre> <p>Description</p> <p>Generates a <code>u32</code> random value in the range <code>[0, bound)</code>. The upper bound is exclusive.</p> <p>It uses a debiasing loop to ensure a uniform distribution.</p> <p>Parameters</p> Name Type Description <code>rng</code> <code>Rng*</code> Pointer to the <code>Rng</code> context. <code>bound</code> <code>u32</code> The exclusive upper bound. If <code>0</code>, the function returns <code>0</code>. <p>Returns</p> <p>A <code>u32</code> value within the range <code>[0, bound)</code> (inclusive of 0 and exclusive of <code>bound</code>).</p> EE_INLINE u64 ee_rand_u64_ab(Rng* rng, u64 a, u64 b) <p></p> <p>Syntax</p> <pre><code>u64 ee_rand_u64_ab(Rng* rng, u64 a, u64 b);\n</code></pre> <p>Description</p> <p>Generates a <code>u64</code> random value in the range <code>[a, b)</code>. The upper bound <code>b</code> is exclusive.</p> <p>Asserts if <code>a &gt; b</code>. If <code>a == b</code>, returns <code>a</code>.</p> <p>Parameters</p> Name Type Description <code>rng</code> <code>Rng*</code> Pointer to the <code>Rng</code> context. <code>a</code> <code>u64</code> The inclusive lower bound. <code>b</code> <code>u64</code> The exclusive upper bound. <p>Returns</p> <p>A <code>u64</code> value within the range <code>[a, b)</code> (inclusive of <code>a</code> and exclusive of <code>b</code>).</p> EE_INLINE u32 ee_rand_u32_ab(Rng* rng, u32 a, u32 b) <p></p> <p>Syntax</p> <pre><code>u32 ee_rand_u32_ab(Rng* rng, u32 a, u32 b);\n</code></pre> <p>Description</p> <p>Generates a <code>u32</code> random value in the range <code>[a, b)</code>. The upper bound <code>b</code> is exclusive.</p> <p>Asserts if <code>a &gt; b</code>. If <code>a == b</code>, returns <code>a</code>.</p> <p>Parameters</p> Name Type Description <code>rng</code> <code>Rng*</code> Pointer to the <code>Rng</code> context. <code>a</code> <code>u32</code> The inclusive lower bound. <code>b</code> <code>u32</code> The exclusive upper bound. <p>Returns</p> <p>A <code>u32</code> value within the range <code>[a, b)</code> (inclusive of <code>a</code> and exclusive of <code>b</code>).</p> EE_INLINE f64 ee_rand_f64_ab(Rng* rng, f64 a, f64 b) <p></p> <p>Syntax</p> <pre><code>f64 ee_rand_f64_ab(Rng* rng, f64 a, f64 b);\n</code></pre> <p>Description</p> <p>Generates a <code>f64</code> random value in the range <code>[a, b)</code>. The upper bound <code>b</code> is exclusive.</p> <p>Asserts if <code>a &gt;= b</code>.</p> <p>Parameters</p> Name Type Description <code>rng</code> <code>Rng*</code> Pointer to the <code>Rng</code> context. <code>a</code> <code>f64</code> The inclusive lower bound. <code>b</code> <code>f64</code> The exclusive upper bound. <p>Returns</p> <p>A <code>f64</code> value within the range <code>[a, b)</code> (inclusive of <code>a</code> and exclusive of <code>b</code>).</p> EE_INLINE f32 ee_rand_f32_ab(Rng* rng, f32 a, f32 b) <p></p> <p>Syntax</p> <pre><code>f32 ee_rand_f32_ab(Rng* rng, f32 a, f32 b);\n</code></pre> <p>Description</p> <p>Generates a <code>f32</code> random value in the range <code>[a, b)</code>. The upper bound <code>b</code> is exclusive.</p> <p>Asserts if <code>a &gt;= b</code>.</p> <p>Parameters</p> Name Type Description <code>rng</code> <code>Rng*</code> Pointer to the <code>Rng</code> context. <code>a</code> <code>f32</code> The inclusive lower bound. <code>b</code> <code>f32</code> The exclusive upper bound. <p>Returns</p> <p>A <code>f32</code> value within the range <code>[a, b)</code> (inclusive of <code>a</code> and exclusive of <code>b</code>).</p>"},{"location":"headers/Random/random/#functions-normal-distribution","title":"Functions (Normal Distribution)","text":"EE_INLINE f64 ee_randn_f64(Rng* rng, f64 mean, f64 std) <p>Syntax</p> <pre><code>f64 ee_randn_f64(Rng* rng, f64 mean, f64 std);\n</code></pre> <p>Description</p> <p>Generates a normally distributed <code>f64</code> random value (also known as a Gaussian random value).</p> <p>It uses the Marsaglia polar method (a variant of the Box-Muller transform) to generate two random values at a time. One value is returned, and the other is cached in the <code>Rng</code> context's <code>spare</code> field for the next call.</p> <p>Parameters</p> Name Type Description <code>rng</code> <code>Rng*</code> Pointer to the <code>Rng</code> context. <code>mean</code> <code>f64</code> The mean (average) &amp;mu of the distribution. <code>std</code> <code>f64</code> The standard deviation &amp;sigma of the distribution. Asserts if $\\lt 0$. <p>Returns</p> <p>A <code>f64</code> random value sampled from the specified normal distribution.</p> EE_INLINE f32 ee_randn_f32(Rng* rng, f32 mean, f32 std)"},{"location":"headers/Random/random/#internal-helper-functions","title":"Internal Helper Functions","text":"<p>These functions are used internally by <code>ee_random.h</code> and are not typically called directly by the end-user.</p> EE_INLINE u64 ee_rotl_u64(u64 x, i32 k) EE_INLINE u64 ee_splitmix_u64(u64* state)"}]}