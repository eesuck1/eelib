{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ee \u2014 Lightweight C Utility Library","text":"<p>eelib is a header-only C library providing common data structures and utilities.</p> <p>It includes implementations for arrays, dictionaries, strings, memory management, and other structures. The library is designed to be used directly in C projects without external dependencies.</p>"},{"location":"#features","title":"Features","text":"<p>The library provides a set of building blocks:</p> <ul> <li> <p>Memory management</p> <ul> <li>Arena allocator (<code>ee_arena.h</code>) for fast, linear allocations.</li> <li>Optional custom allocators via <code>ee_core.h</code>.</li> </ul> </li> <li> <p>Dynamic containers</p> <ul> <li>Resizable vectors (<code>ee_array.h</code>) with automatic growth.</li> <li>Hash maps (<code>ee_dict.h</code>) with open addressing.</li> <li>Binary heaps (<code>ee_heap.h</code>) for priority scheduling.</li> <li>Sets (<code>ee_set.h</code>) with efficient lookup.</li> <li>2D grids (<code>ee_grid.h</code>) for spatial or game-related logic.</li> </ul> </li> <li> <p>String utilities</p> <ul> <li><code>ee_string.h</code> builds on vectors to support dynamic strings, fixed-length buffers, and lightweight string views.</li> </ul> </li> <li> <p>System utilities</p> <ul> <li><code>ee_fs.h</code> for filesystem traversal and file utilities (Windows support).</li> <li><code>ee_random.h</code> for uniform and normal random distributions.</li> </ul> </li> </ul>"},{"location":"#supported-platformscompilers","title":"Supported platforms/compilers","text":"<ul> <li>Minimum C standard: C99</li> <li>Tested with MSVC, GCC</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>There are two ways to use ee in your project:</p> <ul> <li>Clone the repository</li> </ul> <p>Clone or download the repository and add the <code>utils/</code> directory to your include path. This way you get access to all modules at once:</p> <pre><code>git clone https://github.com/eesuck1/eelib.git\n</code></pre> <p>Then in your code:</p> <pre><code>#include \"ee_array.h\"\n#include \"ee_dict.h\"\n#include \"ee_string.h\"\n#include \"ee_arena.h\"\n</code></pre> <ul> <li>Copy specific headers</li> </ul> <p>Since ee is header-only, you can also copy a single header (or a subset) into your project.</p> <p>Note Some headers depend on others. Make sure you copy all required files.</p> Header Description Dependencies <code>ee_arena.h</code> Contains definitions and functions for a linear memory allocator. Depends on <code>ee_core.h</code>. <code>ee_array.h</code> Provides a dynamically resizable contiguous array type for arbitrary element sizes. Supports insertion, deletion, and random access. Depends on <code>ee_core.h</code>. <code>ee_core.h</code> Defines core types, macros, SIMD abstractions, and base memory allocators used throughout the library. Independent. <code>ee_deq.h</code> Implements a double-ended queue (deque) data structure with dynamic resizing and allocator support. Depends on <code>ee_core.h</code>. <code>ee_dict.h</code> Implements an open-addressing hash map for fixed-size keys and values. Used for key-value storage with constant-time access in average cases. Depends on <code>ee_core.h</code>. <code>ee_fs.h</code> Provides functions for reading files, iterating directories, and handling file paths on Windows systems. Depends on <code>ee_array.h</code>, <code>ee_string.h</code>. <code>ee_grid.h</code> Defines a 2D grid container with utilities for accessing subregions and performing pathfinding operations. Depends on <code>ee_array.h</code>, <code>ee_dict.h</code>, <code>ee_heap.h</code>. <code>ee_heap.h</code> Implements a binary heap structure for managing priority queues with custom comparison logic. Depends on <code>ee_array.h</code>. <code>ee_random.h</code> Provides pseudo-random number generation for integer and floating-point types with uniform and normal distributions. Depends on <code>ee_core.h</code>. <code>ee_set.h</code> Implements a set container based on a Red-Black tree layout for storing unique elements in sorted order. Depends on <code>ee_array.h</code>. <code>ee_string.h</code> Provides string types and utilities for dynamic, fixed-size, and view-based string manipulation in C. Depends on <code>ee_core.h</code>."},{"location":"#ee_no_assert-usage","title":"<code>EE_NO_ASSERT</code> usage","text":"<p>Defining <code>EE_NO_ASSERT</code> before including header disables all <code>EE_ASSERT()</code> checks at compile time.</p> Mode Description With <code>EE_ASSERT</code>  (default) <code>EE_ASSERT</code> validates conditions and terminates on failure. With <code>EE_NO_ASSERT</code> Assertions are removed \u2014 no checks or runtime overhead. <p>Usage example:</p> <pre><code>#define EE_NO_ASSERT\n\n#include \"ee_core.h\"\n</code></pre> <p>Use this to exclude safety checks in release builds for better performance.</p>"},{"location":"#simd-levels","title":"SIMD Levels","text":"<p>SIMD levels define the width and type of vector instructions supported by the processor.</p> <p>The library supports multiple SIMD optimization levels:</p> Macro Value Description <code>EE_SIMD_LEVEL_NONE</code> 0 No SIMD instructions; operations are scalar. <code>EE_SIMD_LEVEL_SSE</code> 1 Supports 128-bit vector instructions for ints and floats. <code>EE_SIMD_LEVEL_AVX</code>(default) 2 Supports 256-bit vector instructions for higher parallelism."},{"location":"headers/Arena/arena/","title":"ee_arena","text":"<p><code>ee_arena.h</code> provides a linear memory allocator with optional rewind support. It defines the <code>Arena</code> structure, containing a buffer, allocation offset, mark stack, and allocator callbacks.</p> <p>Memory is allocated from a contiguous buffer with alignment handling; marks allow rewinding to previous offsets.</p> <p>The arena can be wrapped as a standard <code>Allocator</code> using <code>ee_arena_allocator()</code>.</p> EE_INLINE Arena ee_arena_new(size_t size, size_t rewind_depth, Allocator* allocator) <p>Decription</p> <p>Initialize a new memory arena with a given <code>size</code> and optional <code>rewind_depth</code>.</p> <p>If <code>allocator</code> is <code>NULL</code>, the default allocator is used. Returns an <code>Arena</code> structure ready for allocations.</p> <p>Parameters</p> Name Type Description size size_t Total arena buffer size in bytes. rewind_depth size_t Number of marks that can be stored for rewinding. Use <code>EE_NO_REWIND</code> to disable. allocator Allocator* Optional custom allocator. If <code>NULL</code>, defaults are used. <p>Example</p> <pre><code>Arena arena = ee_arena_new(1024, 4, NULL);\nvoid* block = ee_arena_alloc(&amp;arena, 128);\n</code></pre> EE_INLINE void ee_arena_clear(Arena* arena) <p>Description</p> <p>Clears the arena buffer by setting all bytes to zero without freeing memory.</p> <p>Parameters</p> Name Type Description arena Arena* Pointer to the arena object. <p>Example</p> <pre><code>ee_arena_clear(&amp;arena);\n</code></pre> EE_INLINE void* ee_arena_alloc(Arena* arena, size_t size) <p>Description</p> <p>Allocates a memory block of size bytes from the arena.</p> <p>Returns <code>NULL</code> if there isn\u2019t enough space is available.</p> <p>Parameters</p> Name Type Description arena Arena* Pointer to the arena object. size size_t Number of bytes to allocate. <p>Example</p> <pre><code>void* data = ee_arena_alloc(&amp;arena, 256);\n</code></pre> EE_INLINE void* ee_arena_alloc_al(Arena* arena, size_t size, size_t align) <p>Description</p> <p>Allocates a memory block of <code>size</code> bytes from the arena with a specified alignment.</p> <p>Returns <code>NULL</code> if not enough aligned space is available.</p> <p>Parameters</p> Name Type Description arena Arena* Pointer to the arena object. size size_t Number of bytes to allocate. align size_t Alignment in bytes (must be power of two). <p>Example</p> <pre><code>void* aligned_data = ee_arena_alloc_al(&amp;arena, 128, 16);\n</code></pre> EE_INLINE void ee_arena_mark(Arena* arena) <p>Description</p> <p>Marks the current allocation position in the arena so it can be rewound later. Useful for temporary allocations.</p> <p>Parameters</p> Name Type Description arena Arena* Pointer to the arena object. <p>Example</p> <pre><code>ee_arena_mark(&amp;arena);\n// allocate something temporary\n</code></pre> EE_INLINE void ee_arena_rewind(Arena* arena) <p>Description</p> <p>Restores the arena\u2019s allocation state to the last saved mark, effectively freeing allocations made after that mark.</p> <p>Parameters</p> Name Type Description arena Arena* Pointer to the arena object. <p>Example</p> <pre><code>ee_arena_rewind(&amp;arena);\n</code></pre> EE_INLINE void ee_arena_reset(Arena* arena) <p>Description</p> <p>Resets the arena to its initial state, clearing all marks and allocations. Does not free memory \u2014 only resets internal offsets.</p> <p>Parameters</p> Name Type Description arena Arena* Pointer to the arena object. <p>Example</p> <pre><code>ee_arena_reset(&amp;arena);\n</code></pre> EE_INLINE void ee_arena_free(Arena* arena) <p>Description</p> <p>Frees all arena memory and resets its internal state to zero.</p> <p>Parameters</p> Name Type Description arena Arena* Pointer to the arena object. <p>Example</p> <pre><code>ee_arena_free(&amp;arena);\n</code></pre> EE_INLINE void* eev_arena_alloc_fn(Allocator* allocator, size_t size) <p>Description</p> <p>Allocator callback for arena-based allocation. This function integrates the arena with generic allocator interfaces.</p> <p>Parameters</p> Name Type Description allocator Allocator* Pointer to the allocator object. size size_t Number of bytes to allocate. <p>Example</p> <pre><code>Allocator a = ee_arena_allocator(&amp;arena);\nvoid* mem = eev_arena_alloc_fn(&amp;a, 64);\n</code></pre> EE_INLINE void* eev_arena_realloc_fn(Allocator* allocator, void* buffer, size_t old_size, size_t new_size) <p>Description</p> <p>Stub implementation of realloc for arena allocator (always returns <code>NULL</code>). Arena memory is not resizable.</p> <p>Parameters</p> Name Type Description allocator Allocator* Pointer to the allocator object. buffer void* Pointer to existing buffer. old_size size_t Original buffer size (unused). new_size size_t Requested size (unused). <p>Example</p> <pre><code>void* p = eev_arena_realloc_fn(&amp;allocator, ptr, 64, 128); // always returns NULL\n</code></pre> EE_INLINE void eev_arena_free_fn(Allocator* allocator, void* buffer) <p>Description</p> <p>Stub implementation of free for arena allocator (does nothing). Arena allocations are released only via <code>ee_arena_reset</code> or <code>ee_arena_free</code>.</p> <p>Parameters</p> Name Type Description allocator Allocator* Pointer to allocator. buffer void* Pointer to buffer (unused). <p>Example</p> <pre><code>eev_arena_free_fn(&amp;allocator, ptr); // no effect\n</code></pre> EE_INLINE Allocator ee_arena_allocator(Arena* arena) <p>Description</p> <p>Creates an <code>Allocator</code> object that uses the specified <code>Arena</code> for its memory operations.</p> <p>Parameters</p> Name Type Description arena Arena* Pointer to the arena object. <p>Example</p> <pre><code>Allocator a = ee_arena_allocator(&amp;arena);\n</code></pre>"}]}